package com.blackwell.arraysort;

/**
 * Используем ту же идею, что и сортировка с расческой, и применим к сортировке вставками.
 * Зафиксируем некоторое расстояние. Тогда элементы массива разобьются на классы –
 * в один класс попадают элементы, расстояние между которыми кратно зафиксированному расстоянию.
 * Отсортируем сортировкой вставками каждый класс. В отличие от сортировки расческой,
 * неизвестен оптимальный набор расстояний. Существует довольно много последовательностей с разными оценками.
 * Последовательность Шелла – первый элемент равен длине массива, каждый следующий вдвое меньше предыдущего.
 * Асимптотика в худшем случае – O(n2). Последовательность Хиббарда – 2n — 1, асимптотика в худшем случае – O(n1,5),
 * последовательность Седжвика (формула нетривиальна, можете ее посмотреть по ссылке ниже) — O(n4/3),
 * Пратта (все произведения степеней двойки и тройки) — O(nlog2n). Отмечу, что все эти последовательности нужно
 * рассчитать только до размера массива и запускать от большего от меньшему (иначе получится просто сортировка вставками).
 * Также я провел дополнительное исследование и протестировал разные последовательности вида
 * si = a * si — 1 + k * si — 1 (отчасти это было навеяно эмпирической последовательностью Циура – одной из лучших
 * последовательностей расстояний для небольшого количества элементов). Наилучшими оказались последовательности
 * с коэффициентами a = 3, k = 1/3; a = 4, k = 1/4 и a = 4, k = -1/5.
 */

public class Shell {
    public static long sort(int[] array) {
        long StartTime = System.nanoTime();

        int gap = array.length / 2;
        while (gap > 0) {
            for (int i = 0; i < array.length - gap; i++) { //modified insertion sort
                int j = i + gap;
                int tmp = array[j];
                while (j >= gap && tmp < array[j - gap]) {
                    array[j] = array[j - gap];
                    j -= gap;
                }
                array[j] = tmp;
            }
            if (gap == 2) { //change the gap size
                gap = 1;
            } else {
                gap /= 2.2;
            }
        }


        long EndTime = System.nanoTime();
        return EndTime-StartTime;
    }
}
